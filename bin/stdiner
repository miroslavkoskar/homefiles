#!/usr/bin/env bash

set -eu -o pipefail

prgname=${0##*/}

_usage() {
    cat <<-EOF
	usage: $prgname [-t | -T] cmd [arg]..."

	Execute 'cmd [arg]...' with stdin reference replacing '{}' placehoder/s
	or as last dynamic argument if no '{}' placeholder was used.

	  -t    - read stdin to temporary file first which will be removed on EXIT
	  -T    - same as 't' but temporary file is removed with some timeout
	EOF
}
usage() { _usage; exit 0; }
usage_err() { _usage; exit 2; } >&2

declare -i topt=0 Topt=0
while getopts 'tTh' opt; do
    case $opt in
        t)
            topt=1
            ;;
        T)
            Topt=1
            ;;
        h)
            usage
            ;;
        *)
            usage_err
            ;;
    esac
done
shift $((OPTIND-1))

(( $# )) || usage_err

# ----------------------------------------

if [[ -t 0 ]]; then
    echo 'stdin is a tty' >&2
    exit 1
fi

if (( topt || Topt )); then
    file=$(mktemp -t 'stdiner.XXXXXXXXXX')
    cleanup() { rm -f "$file"; }
    trap cleanup EXIT
    cat >"$file"
else
    exec 8<&0
    file='/dev/fd/8'
fi

exec </dev/tty

args=("$@")
declare -i farg=0
for i in "${!args[@]}"; do
    if [[ ${args[$i]} = '{}' ]]; then
        args[$i]=$file
        farg=1
    fi
done
(( farg )) || args+=("$file")

(exec "${args[@]}")

if (( Topt )); then
    {
        trap cleanup EXIT
        sleep 30
        while fuser "$file"; do sleep 1; done
    } &
    trap - EXIT
fi
