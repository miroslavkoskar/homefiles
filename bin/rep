#!/usr/bin/env bash

set -eu

prgname=${0##*/}

_usage() {
    cat <<-EOF
	usage: $prgname [-d delay] [-t] [-T delta] [-o output] [-a] [-i] [-I] [-q] cmd [arg]...

	Execute 'cmd [arg]...' repeatedly.

	  -d delay  - wait for 'delay' milliseconds; <0 = wait forever, 0 = don't wait at all (default: -1)
	  -t        - terminate if 'cmd' finished in less than 'delta' milliseconds
	  -T delta  - (default: 400)
	  -o output - redirect stdout and sterr to 'output'
	  -a        - don't truncate 'output' but do append instead
	  -i        - inline (don't use alternate screen)
	  -I        - don't hide cursor
	  -q        - quiet
	  -h        - show this help message and exit
	EOF
}
usage() { _usage; exit 0; }
usage_err() { _usage; exit 2; } >&2

if [[ $prgname = 'respawn' ]]; then
    set -- -d0 -t "$@"
fi

dopt= term=0 Topt= redir= output= inline=0 cur=0 quiet=0
while getopts 'd:tT:o:aiIcCqh' opt; do
    case $opt in
        d)
            [ "$OPTARG" -eq "$OPTARG" ] 2>/dev/null || {
                echo "$prgname: option requires an integer argument -- $opt" >&2
                usage_err
            }
            dopt=$OPTARG
            ;;
        t)
            term=1
            ;;
        T)
            [ "$OPTARG" -gt 0 ] 2>/dev/null || {
                echo "$prgname: option requires a positive integer argument -- $opt" >&2
                usage_err
            }
            Topt=$OPTARG
            ;;
        o)
            redir='>'
            output=$OPTARG
            ;;
        a)
            redir='>>'
            ;;
        i)
            inline=1
            ;;
        I)
            cur=1
            ;;
        q)
            quiet=1
            ;;
        h)
            usage
            ;;
        *)
            usage_err
            ;;
    esac
done
shift $((OPTIND-1))

(( $# )) || usage_err

delay=${dopt:--1}
term_delta=${Topt:-400}

notty=0
if [[ ! -t 0 ]]; then
    if (( delay < 0 )); then
        echo "$prgname: stdin not being a tty doesn't go with negative delay" >&2
        exit 2
    fi
    notty=1
fi

read_opts=(-N1 -rs)
if (( delay > 0 )); then
    delay_s=$(bc -l <<<"scale=2; $delay/1000")
    read_opts+=(-t "$delay_s")
fi

ti_el=$(tput el)

if (( ! inline )); then
    tput smcup
    tput clear
    tput sc
    (( cur )) || tput civis
    cleanup() { tput cnorm; tput rmcup; }
    trap cleanup EXIT
fi

while true; do
    (( ! inline )) && tput rc
    (( ! quiet )) && printf "> started: %s${ti_el}\n" "$(date +%T)" >&2
    (( term )) && t_begin=$(date +%s.%N)

    if [[ $output ]]; then
        bashx -c "$(shell-escape "$@")" "$redir" "$output" 2>&1
    else
        bashx -c "$(shell-escape "$@")" 2>&1 | sed "s/\$/$ti_el/"
    fi

    if (( term )); then
        t_end=$(date +%s.%N)
        (( $(bc -l <<<"($t_end-$t_begin) < $term_delta/1000") == 1 )) && break
    fi

    if (( notty && delay > 0 )); then
        (( ! inline )) && tput ed
        sleep "$delay_s"
        continue
    fi

    if (( delay != 0 )); then
        if (( ! quiet )); then
            h=
            (( delay > 0 )) && h="waiting for ${delay}ms, "
            h="${h}press any key to start or q|Q to quit"
            printf "> finished: %s (%s)${ti_el}\n" "$(date +%T)" "$h" >&2
            (( ! inline )) && tput ed
        fi
        read "${read_opts[@]}" c || continue
        case $c in q|Q) break ;; esac
    fi
done
