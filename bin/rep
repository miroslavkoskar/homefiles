#!/bin/bash

set -eu

prgname=$(basename "$0")

_usage() {
    cat <<-EOF
	usage: $prgname [-d delay] [-t] [-T delta] [-o output] [-a] [-i] [-I] [-q] cmd [arg]...

	Execute 'cmd [arg]...' repeatedly.

	  -d delay  - wait for 'delay' milliseconds; <0 = wait forever, 0 = don't wait at all (default: -1)
	  -t        - terminate if 'cmd' finished in less than 'delta' milliseconds
	  -T delta  - (default: 400)
	  -o output - redirect stdin and sterr to 'output'
	  -a        - don't truncate 'output' but do append instead
	  -i        - inline (don't use alternate screen)
	  -I        - don't hide cursor
	  -q        - quiet
	  -h        - show this help message and exit
	EOF
}
usage() { _usage; exit 0; }
usage_err() { _usage; exit 2; } >&2

if [ "$prgname" = 'respawn' ]; then
    set -- -d0 -t "$@"
fi

dopt= term= Topt= redir= output= inline= cur= copt= quiet=
while getopts 'd:tT:o:aiIcCqh' opt; do
    case $opt in
        d)
            [ "$OPTARG" -eq "$OPTARG" ] 2>/dev/null || {
                echo "$prgname: option requires an integer argument -- $opt" >&2
                usage_err
            }
            dopt=$OPTARG
            ;;
        t)
            term=1
            ;;
        T)
            [ "$OPTARG" -gt 0 ] 2>/dev/null || {
                echo "$prgname: option requires a positive integer argument -- $opt" >&2
                usage_err
            }
            Topt=$OPTARG
            ;;
        o)
            redir='>'
            output=$OPTARG
            ;;
        a)
            redir='>>'
            ;;
        i)
            inline=1
            ;;
        I)
            cur=1
            ;;
        c)
            copt=1
            ;;
        C)
            copt=0
            ;;
        q)
            quiet=1
            ;;
        h)
            usage
            ;;
        *)
            usage_err
            ;;
    esac
done
shift $((OPTIND-1))

if [ $# -eq 0 ]; then
    usage_err
fi

delay=${dopt:--1}
term_delta=${Topt:-400}

notty=1
if [ ! -t 0 ]; then
    if ((delay < 0)); then
        echo "$prgname: stdin not being a tty doesn't go with negative delay" >&2
        exit 2
    fi
    notty=1
fi

read_opts=(-N1 -rs)
if ((delay > 0)); then
    delay_s=$(bc -l <<<"scale=2; $delay/1000")
    read_opts+=(-t "$delay_s")
fi

eval_opts=
if [ -n "$output" ]; then
    eval_opts+=("$redir" "$output" '2>&1')
fi

if [ -z "$inline" ]; then
    tput smcup
    tput clear
    [ -n "$cur" ] || tput civis

    cleanup() {
        tput cnorm
        tput rmcup
    }
    trap cleanup EXIT
fi

while true; do
    [ -z "$inline" ] && tput clear
    [ -z "$quiet" ] && printf -- '> started: %s\n' "$(date '+%H:%M:%S')" >&2
    [ -n "$term" ] && t_begin=$(date +%s.%N)

    bashx -c "$(shell-escape "$@")" "${eval_opts[@]}"

    if [ -n "$term" ]; then
        t_end=$(date +%s.%N)
        [ "$(bc -l <<<"($t_end-$t_begin) < $term_delta/1000")" -eq 1 ] && break
    fi

    if [ -n "$notty" -a $delay -gt 0 ]; then
        sleep "$delay_s"
        continue
    fi

    if [ $delay -ne 0 ]; then
        if [ -z "$quiet" ]; then
            h=
            [ $delay -gt 0 ] && h="waiting for ${delay}ms, "
            h="${h}press any key to start or q|Q to quit"
            printf -- '> finished: %s (%s)\n' "$(date '+%H:%M:%S')" "$h" >&2
        fi
        read "${read_opts[@]}" c || continue
        case $c in q|Q) break ;; esac
    fi
done
