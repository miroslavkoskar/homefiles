" vim: ft=vim fdm=marker

let vimrc = get(g:, 'vimrc', expand('<sfile>:p'))
source ~/.vim/vimrc_base

set nomodifiable
set buftype=nowrite

set nolist
set colorcolumn=0
set laststatus=1
set tabstop=8
set virtualedit=all

set nobackup
set noswapfile
set noundofile
set undolevels=-1

set shell=~/bin/bashx
exec "set viminfo=!,'100,<50,s10,h,n".$VIMDIR."/.viminfo_pg"

noremap <silent> q :qa<CR>

map <silent> r :Preserve edit<CR>
nnoremap <silent> <C-A> :AnsiEsc<CR>

let loaded_getscriptPlugin = 1
let loaded_rrhelper = 1
let loaded_spellfile_plugin = 1
let loaded_vimballPlugin = 1

function! NoFileSetup() abort
    setl buftype=nofile
    noremap <buffer> r <Nop>
    noremap <buffer> R <Nop>
    noremap <buffer> F <Nop>
    file $PAGER_TITLE
endfunction

" {{{ Reloads buffer after number (defaults to 1) of seconds have passed.

function! Reload(...) abort
    let d = 1
    if exists('a:1')
        let d = a:1
    endif
    try
        echohl WarningMsg | echo 'Reload in '.d.'s (interrupt to abort)' | echohl None
        exec 'sleep '.d
        if exists(':ReloadX')
            Preserve silent call _ReloadX()
        else
            Preserve edit
        endif
    finally
        redraw
        echo
    endtry
endfunction
command! -nargs=? Reload call Reload(<f-args>)
map <silent> R :Reload<CR>R<CR>
map <silent> F :Reload<CR>GF<CR>

" }}}

if exists('$CMD')

" {{{ Reloads buffer from $CMD.

function! _ReloadX() abort
    try
        setl modifiable
        exec 'silent 0read! '.escape($CMD, '%')
        silent keepjumps normal! jdG
        setl noma
    endtry
endfunction

function! ReloadX() abort
    setl buftype=nofile
    silent file $PAGER_TITLE
    Preserve silent call _ReloadX()
    redraw
    echohl WarningMsg | echo '['.strftime('%H:%M:%S').'] '.$PAGER_TITLE | echohl None
endfunction
command! ReloadX call ReloadX()
map <silent> r :ReloadX<CR>

" }}}

endif

augroup vimrc_pg
    autocmd!

    if exists('$PRGNAME') && $PRGNAME == 'pg0'
        autocmd BufRead * setl noml ft=
    else
        autocmd BufRead,FilterReadPost * if !exists('b:AnsiEsc') | let b:AnsiEsc = 1 | exec 'AnsiEsc' | endif
        autocmd BufUnload * if exists('b:AnsiEsc') | exec 'AnsiEsc' | unlet b:AnsiEsc | endif
    endif

augroup END

exec VimrcFinalize()
