" vim: ft=vim fdm=marker

let vimrc = get(g:, 'vimrc', expand('<sfile>:p'))
let vimdir_data = has('nvim') ? $HOME.'/.local/share/nvim' : $HOME.'/.vim'

if empty($VIMDIR)
    let $VIMDIR = vimdir_data
else
    if isdirectory($VIMDIR)
        let $VIMDIR = fnamemodify($VIMDIR, ':p:h')
        let &rtp = join([escape($VIMDIR, '\,'), &rtp, escape($VIMDIR.'/after', '\,')], ',')
    else
        call utils#echoError(printf("%s: VIMDIR is not a valid directory", $VIMDIR))
        let $VIMDIR = vimdir_data
    endif
endif


" Important
" ----------------------------------------

set nocompatible
set pastetoggle=<F6>

let mapleader = ','
let maplocalleader = ';'


" Moving Around, Searching and Patterns
" ----------------------------------------

set ignorecase
set incsearch
set path=.,,**
set smartcase
set whichwrap=b,s,<,>,[,]

if empty(maparg('\', 'n'))
    noremap <silent> \ ,
    sunmap \
endif

noremap <silent> j gj
noremap <silent> k gk

map <silent> <M-j> 5j
map <silent> <M-k> 5k

noremap <silent> <M-C-H> 10h
noremap <silent> <M-C-L> 10l

noremap <silent> <C-E> 5<C-E>
noremap <silent> <C-Y> 5<C-Y>

noremap <silent> zh 10zh
noremap <silent> zl 10zl

" Move visual block <http://vimrcfu.com/snippet/77>
xnoremap J :move '>+1<CR>gv
xnoremap K :move '<-2<CR>gv


" Tags
" ----------------------------------------

set tags-=./tags tags-=./tags; tags^=./tags;

nnoremap <silent> <F12> :call system('mktags')
    \ \| call utils#echoWarn('mktags finished')<CR>
nnoremap <Leader>lt :ltag /


" Displaying Text
" ----------------------------------------

set display=lastline
set fillchars=
set list
set listchars=eol:Â¬,tab:>-,trail:-,extends:>,precedes:<,nbsp:+
set nowrap
set scrolloff=2
set sidescroll=10
set sidescrolloff=10

nnoremap <Leader>L :setl <C-R>=&list ? 'nolist' : 'list'<CR><CR>
nnoremap <Leader>U :setl display<C-R>=&display =~# 'uhex' ? '-' : '+'<CR>=uhex<CR>
nnoremap <Leader>W :setl <C-R>=&wrap ? 'nowrap' : 'wrap'<CR><CR>


" Syntax, Highlighting and Spelling
" ----------------------------------------

set colorcolumn=80
set hlsearch
set spelllang=en_us

let c_comment_strings = 1
let load_doxygen_syntax = 1
let python_highlight_all = 1

nnoremap <silent> <Space> :nohlsearch \| echo<CR>
nnoremap <silent> # :let @/ = '\V'.escape(expand('<cWORD>'), '\/') \| set hls<CR>
nnoremap <silent> * :let @/ = '\V'.escape(expand('<cword>'), '\/') \| set hls<CR>

nnoremap cuc :setl <C-R>=&cuc ? 'nocuc' : 'cuc'<CR><CR>
nnoremap cul :setl <C-R>=&cul ? 'nocul' : 'cul'<CR><CR>
nnoremap <Leader>V :setl <C-R>=&virtualedit =~# 'all' ? 'virtualedit=block' : 'virtualedit=all'<CR><CR>
nnoremap <Leader>col :setl <C-R>=!empty(&cc) ? 'cc=' : 'cc<'<CR><CR>
nnoremap <Leader>sp :setl <C-R>=&spell ? 'nospell' : 'spell'<CR><CR>

function! s:ColorsReset() abort
    if has('gui_running')
        colorscheme bclear
    else
        if &t_Co < 256
            colorscheme desert
        else
            colorscheme luciusblack
        endif
    endif
endfunction

command! -bar ColorsReset call s:ColorsReset()
command! -bar Hitest call s:MetaLess('silent runtime syntax/hitest.vim')


" Multiple Windows
" ----------------------------------------

set hidden
set laststatus=2
set splitbelow
set splitright
set winheight=5

set statusline=
    \ statusline+=%n
    \ statusline+=\ %<%f
    \ statusline+=%(\ %{exists('b:run_title')\ ?\ b:run_title\ :\ ''}%)
    \ statusline+=%(\ [%M%W%R]%)
    \ statusline+=%(\ %y%)
    \ statusline+=%=
    \ statusline+=0x%-3B
    \ statusline+=\ %-14(%l,%c%V%)
    \ statusline+=\ %P

nnoremap <silent> <C-J> <C-W>j
nnoremap <silent> <C-K> <C-W>k
nnoremap <silent> <C-H> <C-W>h
nnoremap <silent> <C-L> <C-W>l
nmap <silent> <BS> <C-H>

nnoremap <silent> c<C-J> :below sp<CR>
nnoremap <silent> c<C-K> :above sp<CR>
nnoremap <silent> c<C-H> :lefta vsp<CR>
nnoremap <silent> c<C-L> :rightb vsp<CR>
nmap <silent> c<BS> c<C-H>

nnoremap <silent> d<C-J> <C-W>j<C-W>c<C-W>p
nnoremap <silent> d<C-K> <C-W>k<C-W>c<C-W>p
nnoremap <silent> d<C-H> <C-W>h<C-W>c<C-W>p
nnoremap <silent> d<C-L> <C-W>l<C-W>c<C-W>p
nmap <silent> d<BS> d<C-H>

nnoremap <silent> <C-_> <C-W>_
nnoremap <silent> g<C-J> <C-W>j<C-W>_
nnoremap <silent> g<C-K> <C-W>k<C-W>_

nnoremap <silent> _ :resize -5<CR>
nnoremap <silent> + :resize +5<CR>
nnoremap <silent> <C-W>, :vertical resize -5<CR>
nnoremap <silent> <C-W>. :vertical resize +5<CR>
nnoremap <silent> <Leader>q :close<CR>


" Multiple Tab Pages
" ----------------------------------------

set tabpagemax=50

nnoremap <silent> <M-h> gT
nnoremap <silent> <M-l> gt
nnoremap <silent> <M-1> 1gt
nnoremap <silent> <M-2> 2gt
nnoremap <silent> <M-3> 3gt
nnoremap <silent> <M-4> 4gt
nnoremap <silent> <M-5> 5gt
nnoremap <silent> <M-6> 6gt
nnoremap <silent> <M-7> 7gt
nnoremap <silent> <M-8> 8gt
nnoremap <silent> <M-9> 9gt
nnoremap <silent> <M-0> :tablast<CR>
nnoremap <silent> <M-n> :tabnew<CR>
nnoremap <silent> <M-N> :tab split<CR>
nnoremap <silent> <M-H> :tabmove -1<CR>
nnoremap <silent> <M-L> :tabmove +1<CR>

function! s:QuitTab(bang) abort
    try
        exec 'tabclose'.a:bang
    catch /:E784:/
        silent exec empty(a:bang) ? 'qall' : 'cquit'
    endtry
endfunction

command! -bang -bar QuitTab call utils#tryCatchCall('<SID>QuitTab', <q-bang>)
nnoremap <silent> QQ :QuitTab<CR>
nnoremap <silent> QA :QuitTab!<CR>


" Terminal
" ----------------------------------------

if !has('nvim')
    set nottybuiltin
    set ttyfast
    set t_ut=
    set t_BE=[?2004h
    set t_BD=[?2004l
    set t_PS=[200~
    set t_PE=[201~
else
    tnoremap <C-\> <C-\><C-n>
endif

set title


" Using the Mouse
" ----------------------------------------

set mouse=


" TUI/GUI
" ----------------------------------------

if !has('nvim')
    let &t_EI = "\e[2 q"
    let &t_SR = "\e[4 q"
    let &t_SI = "\e[6 q"
endif

set guicursor+=a:blinkon0
set guifont=Monaco\ 12
set guioptions+=c
    \ guioptions+=e
    \ guioptions-=L
    \ guioptions-=T
    \ guioptions-=m
    \ guioptions-=r


" Messages and Info
" ----------------------------------------

set ruler
set shortmess=aoOtTWI
set showcmd
set showmode


" Selecting Text
" ----------------------------------------

set clipboard=unnamed

" Yank from cursor to the line end (consistent with D, C)
nnoremap <silent> Y y$

" Select last yanked area (linewise)
nnoremap <silent> <expr> gp '`['.getregtype()[0].'`]'


" Editing Text
" ----------------------------------------

set backspace=indent,eol,start
set complete-=i
set completeopt=longest,menuone
set formatoptions=tcroqln21j
set matchpairs+=<:>
set nojs
set nrformats-=octal
set showmatch
set textwidth=80
set tildeop
set undofile

let &undodir = $VIMDIR.'/.undo'
call utils#mkdir(&undodir)

inoremap <C-B> <Home>
inoremap <C-E> <End>
inoremap <M-h> <Left>
inoremap <M-l> <Right>
inoremap <M-b> <C-Left>
inoremap <M-f> <C-Right>
inoremap <M-w> <C-Right>

inoremap <C-U> <C-G>u<C-U>
inoremap <C-K> <C-G>u<C-O>d$
inoremap <C-W> <C-G>u<C-W>
inoremap <M-d> <C-G>u<C-O>dw
inoremap <M-x> <Delete>

inoremap <M-j> <C-G>j
inoremap <M-k> <C-G>k

inoremap <C-L> <C-K>
inoremap <C-F>f <C-R>=expand('%:t')<CR>
inoremap <C-F>n <C-R>=expand('%:t:r')<CR>
inoremap <C-F>p <C-R>=expand('%:p')<CR>
inoremap <C-F>d <C-R>=expand('%:r')<CR>


" Tabs and Indenting
" ----------------------------------------

set autoindent
set copyindent
set expandtab
set preserveindent
set shiftround
set shiftwidth=4
set smartindent
set smarttab
set tabstop=4


" Folding
" ----------------------------------------

set foldopen-=block

nnoremap <Leader>ff :setl fdm=manual \| normal! zM<CR>
nnoremap <Leader>fi :setl fdm=indent fdn=2 \| normal! zM<CR>
nnoremap <Leader>fm :setl fdm=marker \| normal! zM<CR>
nnoremap <Leader>fs :setl fdm=syntax \| normal! zM<CR>


" Mapping
" ----------------------------------------

set ttimeout
set ttimeoutlen=10


" Reading and Writing Files
" ----------------------------------------

set autoread
set backup
set fileformats+=mac
set modeline

let &backupdir = $VIMDIR.'/.backup'
call utils#mkdir(&backupdir)


" The Swap File
" ----------------------------------------

set swapfile
set updatetime=1000 " also used for CursorHold

let &directory = $VIMDIR.'/.swap//'
call utils#mkdir(&directory)


" Command Line Editing
" ----------------------------------------

set history=1000
set wildcharm=<S-Tab>
set wildmenu
set wildmode=longest,full

" <C-B> <Home>
" <C-E> <End>
cnoremap <M-h> <Left>
cnoremap <M-l> <Right>
cnoremap <M-b> <C-\>e utils#cmdlineMoveWord(0)<CR>
cnoremap <M-f> <C-\>e utils#cmdlineMoveWord(1)<CR>
cnoremap <M-w> <C-\>e utils#cmdlineMoveWord(1)<CR>

" <C-U> - backward kill line
cnoremap <C-K> <C-\>e strpart(getcmdline(), 0, getcmdpos()-1)<CR>
cnoremap <C-W> <C-\>e utils#cmdlineKillWord(0)<CR>
cnoremap <M-d> <C-\>e utils#cmdlineKillWord(1)<CR>
cnoremap <M-x> <Delete>

cnoremap <C-L> <C-K>
cnoremap <C-O> <S-Tab>
cnoremap %% <C-R>=expand('%:h').'/'<CR>


" Executing External Commands
" ----------------------------------------

set shell=bashx
set shellredir=&>%s


" Running 'make' and Jumping To Errors
" ----------------------------------------

set grepformat=%f:%l:%m
set grepprg=grep\ -nH\ --exclude-dir='.svn'\ --exclude-dir='.git'\ --exclude='*.swp'\ --exclude='*~'\ $*

set grepformat=%f:%l:%c:%m
set grepprg=ag\ --vimgrep\ $*

set shellpipe=\|&\ tee

nnoremap <F9> :make!<CR>

nnoremap <silent> <Leader>cl :copen<CR>
nnoremap <silent> <Leader>ll :lopen<CR>

nnoremap <silent> <Leader>J :cnext<CR>
nnoremap <silent> <Leader>K :cNext<CR>

function! s:LocOrQfMove(dir) abort
    try
        echo
        exec 'l'.a:dir
    catch /:E\(42\|776\):/
        exec 'c'.a:dir
    endtry
endfunction

nnoremap <silent> <Leader>j :call utils#tryCatchCall('<SID>LocOrQfMove', 'next')<CR>
nnoremap <silent> <Leader>k :call utils#tryCatchCall('<SID>LocOrQfMove', 'prev')<CR>


" Language Specific
" ----------------------------------------

set keymap=slovak

set iminsert=0
set imsearch=-1


" Various
" ----------------------------------------

set sessionoptions-=blank sessionoptions-=options
set signcolumn=yes
set virtualedit=block

let &viewdir = $VIMDIR.'/.view'
let &viminfo = "!,'100,<50,s10,h,n".$VIMDIR.'/.viminfo'

nnoremap <silent> <Leader>re :redraw!<CR>

" Disable Ex mode
nnoremap Q <Nop>

" Disable Man lookup
nnoremap K <Nop>

" Delete all
nnoremap <silent> <Leader>D :%d<CR>

" Open files faster
nnoremap <Leader>ew :e<Space>
nnoremap <Leader>es :sp<Space>
nnoremap <Leader>ev :vsp<Space>
nnoremap <Leader>et :tabe<Space>
nnoremap <silent> <Leader>ee :e<CR>
nnoremap <silent> <Leader>e0 :e ++binary<CR>
nnoremap <silent> <Leader>E :e!<CR>

" Read / Filter faster
nnoremap <Leader>% :%!
nnoremap <Leader>ri :r!

" Unload current buffer and delete if from buffer list
nnoremap <silent> <C-Q> :bd<CR>

" Readonly / Modifiable
nnoremap <Leader>ro :setl ro noma<CR>
nnoremap <Leader>ma :setl ma noro<CR>

" Scratch buffer
nnoremap <silent> <Leader>sc :new +setl\ bt=nofile\ bh=wipe\ noswf<CR>

" Reload filetype
nnoremap <silent> <Leader>ft :<C-R>=!empty(&ft) ? 'setf '.&ft : 'filetype detect'<CR><CR>

" Sorting
xnoremap <silent> <Leader>ss :sort<CR>
xnoremap <silent> <Leader>su :sort u<CR>
xnoremap <silent> <Leader>sr :sort!<CR>
xnoremap <silent> <Leader>sb :!sort-blocks<CR>

" Working with diffs
nnoremap <silent> <Leader>d; :,diffget<CR>
nnoremap <silent> <Leader>d: :,diffput<CR>
nnoremap <silent> <Leader>du :diffupdate<CR>
nnoremap <silent> <Leader>dc :only \| diffoff!<CR>

" Help in new tab page
nnoremap <Leader>h :tab help<Space>
nnoremap <Leader>H :tab lhelpgrep<Space>

" Edit / Reload 'vimrc'
nnoremap <silent> <Leader>rc :vs <C-R>=fnameescape(vimrc)<CR><CR>
nnoremap <silent> <Leader>so :source <C-R>=fnameescape(vimrc)<CR>
    \ \| call utils#echoWarn('vimrc reloaded')<CR>

" Hex dump
xnoremap <silent> <Leader>xxd :!xxd<CR>
nnoremap <silent> <Leader>xxd :%!xxd<CR>
xnoremap <silent> <Leader>xxD :!xxd -r<CR>
nnoremap <silent> <Leader>xxD :%!xxd -r<CR>

" Format
xnoremap <silent> <Leader>fo :Format<CR>
nnoremap <silent> <Leader>fo :%Format<CR>

" XML prettify
xnoremap <silent> <Leader>px :Format xml<CR>
nnoremap <silent> <Leader>px :%Format xml<CR>

" Strip / Squash lines
xnoremap <silent> <Leader>ps :!striplns<CR>
nnoremap <silent> <Leader>ps :%!striplns<CR>
xnoremap <silent> <Leader>pS :!squashlns<CR>
nnoremap <silent> <Leader>pS :%!squashlns<CR>

" URLs
xnoremap <silent> <Leader>uo :SystemRange! urls -o<CR>
nnoremap <silent> <Leader>uo :.SystemRange! urls -o<CR>
nnoremap <silent> <Leader>uO :exec line('w0').','.line('w$').'SystemRange! urls -o'<CR>

xnoremap <silent> <Leader>uy :SystemRange! urls -y<CR>
nnoremap <silent> <Leader>uy :.SystemRange! urls -y<CR>
nnoremap <silent> <Leader>uY :exec line('w0').','.line('w$').'SystemRange! urls -y'<CR>

" Git
nnoremap <Leader>gg :vert System git show HEAD:./

" ----------------------------------------

" Formatting {{{

function! s:Format(...) range abort
    let ft = get(a:, 1, &ft)

    "let filename = shellescape(expand('%'), 1)
    "if a:firstline != 1 || a:lastline != v:lnum
    "    let firstline = a:firstline
    "    let lastline = a:lastline
    "endif
    "let shiftwidth = &shiftwidth
    "let textwidth = &textwidth

    exec join([a:firstline.','.a:lastline, '!format', ft])
endfunction

command! -bar -range -nargs=? Format silent Preserve <line1>,<line2> call <SID>Format(<f-args>)

" }}}

" Toggles diff mode of current buffer {{{

function! s:DiffToggle() abort
    exec &diff ? 'diffoff' : 'diffthis'
endfunction

command! -bar DiffToggle call s:DiffToggle()
nnoremap <silent> <Leader>dd :DiffToggle<CR>

" }}}

" Starts diff of current buffer with another file {{{

function! s:DiffTo(file) abort
    let file = fnamemodify(a:file, ':p')
    if isdirectory(file)
        call utils#echoError(printf('"%s" is a directory', fnamemodify(file, ':h')))
        return
    endif
    if !filereadable(file)
        call utils#echoError(printf('"%s" is not readable', file))
        return
    endif
    vnew
    exec 'read ++edit' fnameescape(file) | 0d_
    exec 'setl bt=nofile bh=wipe noswf nobl noma ft='.getbufvar('#', '&ft')
    exec 'silent file DiffTo:\ '.fnameescape(fnamemodify(file, ':~'))
    diffthis
    wincmd p
    diffthis
endfunction

command! -nargs=1 -complete=file DiffTo call s:DiffTo(<q-args>)
nnoremap <Leader>df :DiffTo <C-R>=expand('%')<CR>

" }}}

" Toggles translation of ASCII meta escape prefix encoding to 8 bit meta encoding {{{

function! s:MetaLess(cmd) abort
    exec a:cmd
endfunction

if !has('nvim')

function! s:MetaSetup(enable) abort
    " Meta + [0-z]
    " don't include O and P because of conflicts in xterm
    let chars = '0123456789ABCDEFGHIJKLMNQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    let [i, n] = [0, len(chars)]
    while i < n
        let c = chars[i]
        if a:enable
            exec 'set <M-'.c.">=\e".c
        else
            exec 'set <M-'.c.'>='
        endif
        let i += 1
    endwhile
    " Meta + C-H, C-L
    if a:enable
        exec "set <M-C-H>=\e\x08"
        exec "set <M-C-L>=\e\x0c"
    else
        set <M-C-H>=
        set <M-C-L>=
    endif
    let g:meta_enabled = a:enable
    if !has('vim_starting')
        call utils#echoWarn('meta '.(g:meta_enabled ? 'on' : 'off'))
    endif
endfunction

function! s:MetaLess(cmd) abort
    if g:meta_enabled
        silent call s:MetaSetup(0)
        exec a:cmd
        silent call s:MetaSetup(1)
    else
        exec a:cmd
    endif
endfunction

command! -bar MetaToggle call s:MetaSetup(!meta_enabled)
nnoremap <silent> <Leader>mm :MetaToggle<CR>
silent call s:MetaSetup(1)

endif

" }}}

" Preserve cursor / window position, last search pattern, and the others {{{

function! s:Preserve(cmd) abort
    let view = winsaveview()
    exec 'keepa keepj keepm keepp' a:cmd
    call winrestview(view)
endfunction

command! -nargs=1 Preserve call s:Preserve(<q-args>)
nnoremap <silent> <Leader>pp :Preserve %s/\s\+$//e<CR>
xnoremap <silent> <Leader>pp :<C-U>Preserve '<,'>s/\s\+$//e<CR>
nnoremap <silent> <Leader>== :silent Preserve normal! gg=G<CR>
nnoremap <silent> <Leader>gq :silent Preserve normal! gggqG<CR>

" }}}

" Walks through list of colorschemes (q/C-C=quit, k=prev, default=next) {{{

function! s:Themes() abort
    let themes = ['luciusblack', 'hybrid', 'bclear']
    let l = len(themes)
    if !exists('s:themes_last_index')
        let s:themes_last_index = 0
    endif
    let i = s:themes_last_index
    while 1
        let theme = themes[i]
        exec 'colorscheme' theme
        redraw | echo theme
        let c = getchar()
        if c == 3 || c == 113
            break
        elseif c == 107
            let i = i > 0 ? i-1 : l-1
        else
            let i = i < l-1 ? i+1 : 0
        endif
    endwhile
    let s:themes_last_index = i
    redraw | echo
endfunction

command! Themes call s:Themes()
nnoremap <silent> <Leader>th :Themes<CR>

" }}}

" Write with elevated privileges {{{

function! s:Write(...) abort
    let filename = get(a:, 1, expand('%'))
    exec 'silent write !sudo tee >/dev/null' shellescape(filename, 1)
    edit!
endfunction

command! -nargs=? W call s:Write(<f-args>)

" }}}

" Zoom / Restore window {{{

function! s:ZoomToggle() abort
    if exists('t:zoomed') && t:zoomed
        exec t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vertical resize
        let t:zoomed = 1
    endif
endfunction

command! -bar ZoomToggle call s:ZoomToggle()
nnoremap <silent> <M-m> :ZoomToggle<CR>
nnoremap <silent> <M-z> :ZoomToggle<CR>

" }}}

" MoveToTab <http://vim.wikia.com/wiki/Move_current_window_between_tabs> {{{

function! s:MoveToTab(next) abort
    if tabpagenr('$') == 1 && winnr('$') == 1
        return
    endif
    let tab_nr = tabpagenr('$')
    let cur_buf = bufnr('%')
    if a:next ? tabpagenr() < tab_nr : tabpagenr() != 1
        close!
        if tab_nr == tabpagenr('$')
            exec a:next ? 'tabnext' : 'tabprev'
        endif
        botright vsplit
    else
        close!
        exec a:next ? 'tabnew' : '0tabnew'
    endif
    exec 'buffer' cur_buf
endfunction

command! -bar MoveToNextTab call s:MoveToTab(1)
command! -bar MoveToPrevTab call s:MoveToTab(0)
nnoremap <silent> <C-W><M-h> :MoveToPrevTab<CR>
nnoremap <silent> <C-W><M-l> :MoveToNextTab<CR>

" }}}

" Prev/NextClosedFold <https://stackoverflow.com/questions/9403098/is-it-possible-to-jump-to-closed-folds-in-vim> {{{

function! s:MoveToClosedFold(next) abort
    let cmd = 'normal! z'.(a:next ? 'j' : 'k')
    let view = winsaveview()
    let [lnum0, lnum, isopen] = [0, view.lnum, 1]
    while lnum != lnum0 && isopen
        exec cmd
        let [lnum0, lnum] = [lnum, line('.')]
        let isopen = foldclosed(lnum) < 0
    endwhile
    if isopen
        call winrestview(view)
    endif
endfunction

command! -bar NextClosedFold call s:MoveToClosedFold(1)
command! -bar PrevClosedFold call s:MoveToClosedFold(0)
nnoremap <silent> <Leader>zj :NextClosedFold<CR>
nnoremap <silent> <Leader>zk :PrevClosedFold<CR>

" }}}

" Displaying options {{{

function! s:Option(optname) abort
    if exists('&'.a:optname)
        exec 'echo printf("&g:%s=%s", a:optname, &g:'.a:optname.')'
        exec 'echo printf("&l:%s=%s", a:optname, &l:'.a:optname.')'
    else
        call utils#echoError(printf('"%s" is not an option', a:optname))
    endif
endfunction

command! -nargs=1 -complete=option Option call s:Option(<q-args>)
nnoremap <Leader>oo :Option<Space>

" }}}

" Capture command's output {{{

function! s:Run(system, cmd, input, ...) abort
    if a:system
        let out = systemlist(a:cmd, a:input)
        let reg = 's'
    else
        let out = execute(a:cmd)[1:]
        let reg = 'e'
    endif
    call setreg(reg, out)
    let mode = get(a:, 1, 1)
    if mode is 0 || mode is '!'
        redraw
        echo join(getreg(reg, 1, 1,), "\n")
        return
    endif
    if mode is 1 || mode is ''
        exec get(a:, 2, '') 'new'
    endif
    setl bt=nofile bh=wipe noswf
    let b:run_system = a:system
    let b:run_cmd = a:cmd
    let b:run_input = a:input
    let b:run_title = (a:system ? '!' : ':').a:cmd
    let [ma_, ro_] = [&l:ma, &l:ro]
    setl ma noro
    silent exec 'Preserve %d_ | silent! put' reg '| 1d_'
    let [&l:ma, &l:ro] = [ma_, ro_]
endfunction

command! -count=1 -bang -nargs=1 -complete=command Execute
    \ call utils#tryCatchCall('<SID>Run', 0, <q-args>, [], <count> ? <q-bang> : 2, <q-mods>)
nnoremap <Leader>xe :Execute<Space>

command! -count=1 -bang -nargs=1 -complete=shellcmd System
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, [], <count> ? <q-bang> : 2, <q-mods>)
command! -bang -nargs=1 -complete=shellcmd SystemRegister
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, getreg(v:register, 1, 1), <q-bang>, <q-mods>)
command! -range -bang -nargs=1 -complete=shellcmd SystemRange
    \ call utils#tryCatchCall('<SID>Run', 1, <q-args>, getline(<line1>, <line2>), <q-bang>, <q-mods>)
nnoremap <Leader>xs :System<Space>
xnoremap <Leader>xs y:SystemRegister<Space>

function! s:Reload(bang) abort
    if exists('b:run_system')
        call <SID>Run(b:run_system, b:run_cmd, b:run_input, 2)
        let status = bufname('%')
        let status = empty(status) ? b:run_title : status
    else
        if &l:buftype =~# '^\(nofile\|quickfix\|terminal\)$'
            throw printf("\"%s\" buffer can't be reloaded", &l:buftype)
        endif
        exec 'silent Preserve edit'.a:bang
        let status = v:statusmsg
    endif
    let v:statusmsg = printf('[%s] %s', strftime('%H:%M:%S'), status)
    call utils#echoWarn(v:statusmsg)
endfunction

command! -bang -bar Reload call utils#tryCatchCall('<SID>Reload', <q-bang>)
nnoremap <silent> <Leader>rr :Reload<CR>

function! s:ReloadT(bang, ...) abort
    let d = get(a:, 1, 1)
    try
        let v:statusmsg = ''
        while 1
            call s:Reload('')
            echon printf(' ... sleep for %ds (interrupt to abort)', d)
            if !empty(a:bang)
                normal! G
            endif
            redraw
            exec 'sleep' d
        endwhile
    finally
        call utils#echoWarn(v:statusmsg)
    endtry
endfunction

command! -bang -bar -nargs=? ReloadT call utils#tryCatchCall('<SID>ReloadT', <q-bang>, <f-args>)
nnoremap <silent> <Leader>R :ReloadT<CR>
nnoremap <silent> <Leader>F :ReloadT!<CR>

" }}}

" ----------------------------------------

filetype plugin indent on
if !exists('g:syntax_on')
    syntax enable
endif

" just get rid of these
let loaded_getscript = 1
let loaded_getscriptPlugin = 1
let loaded_logipat = 1
let loaded_netrw = 1
let loaded_netrwPlugin = 1
let loaded_rrhelper = 1
let loaded_vimball = 1
let loaded_vimballPlugin = 1

packadd enhanced-diff | PatienceDiff

packadd! ansiesc
packadd! colorschemes

ColorsReset

augroup vimrc_base
    autocmd!

    autocmd BufEnter,BufWinEnter *
        \  match none
        \| let &titlestring = "%F%( %y%)"
            \. "%( %{exists('w:quickfix_title') ? w:quickfix_title : ''}%)"
            \. "%( %{exists('b:run_title') ? b:run_title : ''}%)"

    autocmd BufWritePre * let &backupext = substitute(expand('%:p:h'), '/', '%', 'g')
    autocmd CmdwinEnter * call utils#bufSpecial()

    "autocmd BufReadPost *
    "    \  if line("'\"") >= 1 && line("'\"") <= line('$')
    "    \|     exec 'normal! g`"'
    "    \| endif

    if !has('nvim')
        autocmd TermChanged * silent call s:MetaSetup(meta_enabled)
    else
        autocmd TermOpen * call utils#bufSpecial()
    endif

    " tabpagecd <https://github.com/kana/vim-tabpagecd>
    autocmd TabEnter *
        \  if exists('t:cwd')
        \|     cd `=t:cwd`
        \| endif
    autocmd TabLeave *
        \ let t:cwd = getcwd()

    autocmd QuickFixCmdPost [^l]* cwindow
    autocmd QuickFixCmdPost l* lwindow

    autocmd BufWritePost ~/.Xresources !xrdb -load ~/.Xresources

    autocmd FileType diff call utils#bufSpecial()
    autocmd FileType mail call utils#bufSpecial() | setl tw=72
    autocmd FileType make setl ts=4 sts=0 sw=4 noet
    autocmd FileType man call utils#bufSpecial() | setl noma ts=8 | unmap <buffer> q
    autocmd FileType tar call utils#bufSpecial()
    autocmd FileType zip call utils#bufSpecial()
    autocmd FileType {c,cpp}{,.*} let &l:path = '.,,**,/usr/include'
augroup END
