" vim: ft=vim fdm=marker

let vimrc = get(g:, 'vimrc', expand('<sfile>:p'))
let vimdir = has('nvim') ? $HOME.'/.config/nvim' : $HOME.'/.vim'

let $VIMDIR = get(g:, '$VIMDIR', vimdir)


" Important
" ----------------------------------------

set nocompatible
set pastetoggle=<F6>

let mapleader = ','
let maplocalleader = ';'


" Moving Around, Searching and Patterns
" ----------------------------------------

set ignorecase
set incsearch
set path=.,,**,
set smartcase
set whichwrap=b,s,<,>,[,]

noremap <silent> j gj
noremap <silent> k gk

map <silent> <M-j> 5j
map <silent> <M-k> 5k

noremap <silent> <M-C-H> 15h
noremap <silent> <M-C-L> 15l

noremap <silent> <C-E> 5<C-E>
noremap <silent> <C-Y> 5<C-Y>

noremap <silent> zh 15zh
noremap <silent> zl 15zl

" Move visual block <http://vimrcfu.com/snippet/77>
vnoremap J :m '>+1<CR>gv
vnoremap K :m '<-2<CR>gv


" Tags
" ----------------------------------------

set tags-=./tags tags-=./tags; tags^=./tags;

if exists('$BASEDIR')
    call system('touch '.$BASEDIR.'/tags')
    nnoremap <silent> <F12> :call system('mktags')
        \ \| echohl WarningMsg \| echo 'mktags finished' \| echohl None<CR>
endif

nnoremap <Leader>lt :ltag /


" Displaying Text
" ----------------------------------------

set display=lastline
set list
set listchars=eol:Â¬,tab:>-,trail:-,extends:>,precedes:<,nbsp:+
set nowrap
set scrolloff=5
set sidescroll=15
set sidescrolloff=15

nnoremap <Leader>L :setl <C-R>=&list ? 'nolist' : 'list'<CR><CR>
nnoremap <Leader>U :setl display<C-R>=&display =~# 'uhex' ? '-' : '+'<CR>=uhex<CR>
nnoremap <Leader>W :setl <C-R>=&wrap ? 'nowrap' : 'wrap'<CR><CR>


" Syntax, Highlighting and Spelling
" ----------------------------------------

set colorcolumn=+1,84
set hlsearch
set spelllang=en_us

let load_doxygen_syntax = 1
let python_highlight_all = 1

nnoremap <silent> <Space> :nohlsearch \| echo<CR>
nnoremap <silent> # :let @/ = "<C-R>=escape(escape(expand('<cWORD>'),
    \ '/\.*$^~["'), '''/\.*$^~["')<CR>" \| set hls<CR>
nnoremap <silent> * :let @/ = "<C-R>=escape(escape(expand('<cword>'),
    \ '/\.*$^~["'), '''/\.*$^~["')<CR>" \| set hls<CR>

nnoremap col :setl <C-R>=!empty(&cc) ? 'cc=' : 'cc<'<CR><CR>
nnoremap cuc :setl <C-R>=&cuc ? 'nocuc' : 'cuc'<CR><CR>
nnoremap cul :setl <C-R>=&cul ? 'nocul' : 'cul'<CR><CR>
nnoremap <Leader>sp :setl <C-R>=&spell ? 'nospell' : 'spell'<CR><CR>

command! Hitest call s:MetaLess('silent source $VIMRUNTIME/syntax/hitest.vim')

if has('vim_starting')
    if &t_Co == 256
        colorscheme luciusblack
    else
        colorscheme desert
    endif
endif


" Multiple Windows
" ----------------------------------------

set laststatus=2
set splitbelow
set splitright
set statusline=
    \ statusline+=%n
    \ statusline+=\ %<%f
    \ statusline+=%(\ [%M%W%R]%)
    \ statusline+=\ [%{&fo}]
    \ statusline+=%(\ %y%)
    \ statusline+=%=
    \ statusline+=0x%-3B
    \ statusline+=\ %-14(%l,%c%V%)
    \ statusline+=\ %P

nnoremap <silent> <C-J> <C-W>j
nnoremap <silent> <C-K> <C-W>k
nnoremap <silent> <C-H> <C-W>h
nnoremap <silent> <C-L> <C-W>l
nmap <silent> <BS> <C-H>

nnoremap <silent> c<C-J> :below sp<CR>
nnoremap <silent> c<C-K> :above sp<CR>
nnoremap <silent> c<C-H> :lefta vsp<CR>
nnoremap <silent> c<C-L> :rightb vsp<CR>
nmap c<BS> c<C-H>

nnoremap <silent> d<C-J> <C-W>j<C-W>c
nnoremap <silent> d<C-K> <C-W>k<C-W>c
nnoremap <silent> d<C-H> <C-W>h<C-W>c
nnoremap <silent> d<C-L> <C-W>l<C-W>c
nmap <silent> d<BS> d<C-H>

nnoremap <silent> <C-_> <C-W>_
nnoremap <silent> g<C-J> <C-W>j<C-W>_
nnoremap <silent> g<C-K> <C-W>k<C-W>_
nnoremap <silent> g<C-H> <C-W>h<C-W>_
nnoremap <silent> g<C-L> <C-W>l<C-W>_
nmap <silent> g<BS> g<C-H>

nnoremap <silent> _ :resize -5<CR>
nnoremap <silent> + :resize +5<CR>
nnoremap <silent> <C-W>, :vertical resize -5<CR>
nnoremap <silent> <C-W>. :vertical resize +5<CR>
nnoremap <silent> <Leader>q :close<CR>


" Multiple Tab Pages
" ----------------------------------------

set tabpagemax=50

nnoremap <silent> <M-n> :tabnew<CR>
nnoremap <silent> <M-l> gt
nnoremap <silent> <M-h> gT
nnoremap <silent> <M-1> 1gt
nnoremap <silent> <M-2> 2gt
nnoremap <silent> <M-3> 3gt
nnoremap <silent> <M-4> 4gt
nnoremap <silent> <M-5> 5gt
nnoremap <silent> <M-6> 6gt
nnoremap <silent> <M-7> 7gt
nnoremap <silent> <M-8> 8gt
nnoremap <silent> <M-9> 9gt
nnoremap <silent> <M-0> :tablast<CR>


" Terminal
" ----------------------------------------

if !has('nvim')
    set nottybuiltin
    set t_ut=
    set ttyfast
endif

set title


" Using the Mouse
" ----------------------------------------

set mouse=

noremap <MiddleMouse> <Nop>
noremap <2-MiddleMouse> <Nop>
noremap <3-MiddleMouse> <Nop>
noremap <4-MiddleMouse> <Nop>

inoremap <MiddleMouse> <Nop>
inoremap <2-MiddleMouse> <Nop>
inoremap <3-MiddleMouse> <Nop>
inoremap <4-MiddleMouse> <Nop>


" GUI
" ----------------------------------------

set guicursor+=a:blinkon0
set guifont=Monaco\ 12
set guioptions+=c
    \ guioptions+=e
    \ guioptions-=L
    \ guioptions-=T
    \ guioptions-=m
    \ guioptions-=r


" Messages and Info
" ----------------------------------------

set ruler
set shortmess=aoOtTWI
set showmode


" Selecting Text
" ----------------------------------------

" Yank from cursor to the line end (consistent with D, C)
nnoremap <silent> Y y$

" Select last yanked area (linewise)
nnoremap <silent> <expr> gp '`['.getregtype()[0].'`]'

" Select all
noremap <silent> <Leader>aa <Esc>:keepjumps normal! ggVG<CR>

function! s:Pipe2(cmd, bang) range abort
    if empty(a:bang)
        exec a:firstline.','.a:lastline.' yank '.v:register
    endif
    call system(a:cmd, getreg())
endfunction
command! -register -range -bang -nargs=1 Pipe2
    \ Preserve silent <line1>,<line2> call s:Pipe2(<q-args>, <q-bang>)
command! -register -range -bang Pipe2Primary
    \ Preserve silent <line1>,<line2> call s:Pipe2('xclip -i', <q-bang>)
command! -register -range -bang Pipe2Clipboard
    \ Preserve silent <line1>,<line2> call s:Pipe2('xclip -i -selection clipboard', <q-bang>)

" Piping to Primary selection directly
nnoremap <silent> <Leader>xxP :Pipe2Primary!<CR>
nnoremap <silent> <Leader>xxp yy:Pipe2Primary!<CR>
vnoremap <silent> <Leader>xxp y:Pipe2Primary!<CR>

" Piping to Clipboard selection directly
nnoremap <silent> <Leader>xxC :Pipe2Clipboard!<CR>
nnoremap <silent> <Leader>xxc yy:Pipe2Clipboard!<CR>
vnoremap <silent> <Leader>xxc y:Pipe2Clipboard!<CR>


" Editing Text
" ----------------------------------------

set backspace=indent,eol,start
set complete-=i
set completeopt=longest,menuone
set formatoptions=tcroqln21j
set nrformats-=octal
set showmatch
set textwidth=78
set tildeop

inoremap <C-U> <C-G>u<C-U>
inoremap <M-j> <C-G>j
inoremap <M-k> <C-G>k
inoremap <M-h> <Left>
inoremap <M-l> <Right>
inoremap <M-H> <S-Left>
inoremap <M-L> <S-Right>

inoremap <silent> <C-F>f <C-R>=expand('%:t')<CR>
inoremap <silent> <C-F>n <C-R>=expand('%:t:r')<CR>
inoremap <silent> <C-F>p <C-R>=expand('%:p')<CR>
inoremap <silent> <C-F>d <C-R>=expand('%:r')<CR>


" Tabs and Indenting
" ----------------------------------------

set autoindent
set copyindent
set expandtab
set preserveindent
set shiftwidth=4
set smartindent
set smarttab
set tabstop=4


" Folding
" ----------------------------------------

nnoremap <Leader>ff :setl fdm=manual \| normal! zM<CR>
nnoremap <Leader>fi :setl fdm=indent \| normal! zM<CR>
nnoremap <Leader>fs :setl fdm=syntax \| normal! zM<CR>
nnoremap <Leader>fm :setl fdm=marker \| normal! zM<CR>


" Mapping
" ----------------------------------------

set ttimeout
set ttimeoutlen=10


" Reading and Writing Files
" ----------------------------------------

set autoread
set backup
set fileformats+=mac
set modeline

let &backupdir = $VIMDIR.'/.backup'


" The Swap File
" ----------------------------------------

set swapfile
set updatetime=1000 " also used for CursorHold

let &directory = $VIMDIR.'/.swap//,'.$TMPDIR.'//'


" Command Line Editing
" ----------------------------------------

set history=1000
set undofile
set wildmenu
set wildmode=longest:full,full

let &undodir = $VIMDIR.'/.undo'

cnoremap %% <C-R>=expand('%:h').'/'<CR>


" Executing External Commands
" ----------------------------------------

set shell=bashx
set shellredir=>%s\ 2>&1


" Running 'make' and Jumping To Errors
" ----------------------------------------

set grepformat=%f:%l:%c:%m
set grepprg=ag\ --vimgrep\ $*
set grepprg=grep\ -nH\ --exclude-dir='.svn'\ --exclude-dir='.git'\ --exclude='*.swp'\ --exclude='*~'\ $*
set shellpipe=2>&1\|\ tee

nnoremap <F9> :make!<CR>

nnoremap <Leader>cl :copen<CR>
nnoremap <Leader>ll :lopen<CR>

nnoremap <silent> <Leader>j :try \| echo \| call TryCatch('lnext',
    \ '^\(.*:E776:.*\)\@!') \| catch \| call TryCatch('cnext') \| endtry<CR>
nnoremap <silent> <Leader>k :try \| echo \| call TryCatch('lNext',
    \ '^\(.*:E776:.*\)\@!') \| catch \| call TryCatch('cNext') \| endtry<CR>

nnoremap <Leader>J :cnext<CR>
nnoremap <Leader>K :cNext<CR>


" Multi-byte Characters
" ----------------------------------------

if has('vim_starting')
    set encoding=utf-8
endif


" Various
" ----------------------------------------

set sessionoptions-=blank sessionoptions-=options
set virtualedit=block

let &viminfo = "!,'100,<50,s10,h,n".$VIMDIR."/.viminfo"

" Disable Ex mode
nnoremap Q <Nop>

" Disable Man lookup
nnoremap K <Nop>

" Delete all
nnoremap <silent> <Leader>D :%d<CR>

" Open files faster
nmap <Leader>ew :e<Space>
nmap <Leader>es :sp<Space>
nmap <Leader>ev :vsp<Space>
nmap <Leader>et :tabe<Space>
nnoremap <silent> <Leader>ee :e<CR>
nnoremap <silent> <Leader>e0 :e ++binary<CR>
nnoremap <silent> <Leader>E :e!<CR>

" Read / Filter faster
nnoremap <Leader>% :%!
nnoremap <Leader>rr :r!

" Unload current buffer and delete if from buffer list
nnoremap <silent> <C-Q> :bd<CR>

" Readonly / Modifiable
nnoremap <Leader>ro :setl ro noma<CR>
nnoremap <Leader>ma :setl ma noro<CR>

" Scratch buffer
nnoremap <silent> <Leader>sc :new +setl\ bt=nofile\ bh=wipe<CR>

" Reload filetype
nnoremap <silent> <Leader>ft :<C-R>=!empty(&ft) ? 'setf '.&ft : 'filetype detect'<CR><CR>

" Sorting
vnoremap <silent> <Leader>ss :sort<CR>
vnoremap <silent> <Leader>su :sort u<CR>
vnoremap <silent> <Leader>sd :sort!<CR>
vnoremap <silent> <Leader>sb :!sort-blocks<CR>

" Working with diffs
nnoremap <silent> <Leader>d; :,diffget<CR>
nnoremap <silent> <Leader>d: :,diffput<CR>
nnoremap <silent> <Leader>du :diffupdate<CR>
nnoremap <silent> <Leader>dc :only \| diffoff!<CR>

" Help in new tab page
nnoremap <Leader>h :tab help<Space>
nnoremap <Leader>H :tab lhelpgrep<Space>

" Edit / Reload 'vimrc'
exec 'nnoremap <silent> <Leader>rc :vs '.fnameescape(vimrc).'<CR>'
exec 'nnoremap <silent> <Leader>so :new \| source '.fnameescape(vimrc).' \| bw!'
    \ '\| echohl WarningMsg \| echo "vimrc reloaded" \| echohl None<CR>'

" xxd
vnoremap <silent> <Leader>xxd :!xxd<CR>
nnoremap <silent> <Leader>xxd :%!xxd<CR>
vnoremap <silent> <Leader>xxD :!xxd -r<CR>
nnoremap <silent> <Leader>xxD :%!xxd -r<CR>

" Format
vnoremap <silent> <Leader>fo :Format<CR>
nnoremap <silent> <Leader>fo :%Format<CR>

" XML prettify
vnoremap <silent> <Leader>px :Format xml<CR>
nnoremap <silent> <Leader>px :%Format xml<CR>

" Strip / Squash lines
vnoremap <silent> <Leader>ps :!striplns<CR>
nnoremap <silent> <Leader>ps :%!striplns<CR>
vnoremap <silent> <Leader>pS :!squashlns<CR>
nnoremap <silent> <Leader>pS :%!squashlns<CR>


" ----------------------------------------

" {{{ Utils

" Echos given error message.
function! EchoError(errmsg) abort
    if empty(a:errmsg)
        redraw
        echohl ErrorMsg | echomsg a:errmsg | echohl None
    endif
endfunction

" Echos most recently caught exception (removing Vim 'class').
function! EchoException() abort
    redraw
    echohl ErrorMsg
    echo substitute(v:exception, '^Vim(.*):', '', 'g')
    echohl None
endfunction

" Echos last given error message.
function! EchoLastError() abort
    call EchoError(v:errmsg)
endfunction

" Performs exec of passed command in try/catch block catching matching errors.
function! TryCatch(cmd, ...) abort
    let pattern = get(a:, '1', '.*')
    exec 'try | exec "'.escape(a:cmd, '"')
        \ '" | catch /'.pattern.'/ | call EchoException() | endtry'
endfunction

function! BufSpecialSetup() abort
    setl nonu nornu nowrap nolist nobl cc=0 fdc=0
endfunction

" }}}

" {{{ Formatting

function! s:Format(...) range abort
    let ft = get(a:, '1', &ft)

    "let filename = shellescape(expand('%'))
    "if a:firstline != 1 || a:lastline != v:lnum
    "    let firstline = a:firstline
    "    let lastline = a:lastline
    "endif
    "let shiftwidth = &shiftwidth
    "let textwidth = &textwidth

    exec join([a:firstline.','.a:lastline, '!format', ft])
endfunction

command! -range -nargs=? Format Preserve silent <line1>,<line2> call s:Format(<f-args>)

" }}}

" {{{ Improve Quickfix

function! s:QfOldest(prefix) abort
    try | exec a:prefix.'older 999' | catch | endtry
endfunction

function! s:QfNewest(prefix) abort
    try | exec a:prefix.'newer 999' | catch | endtry
endfunction

function! s:QfOlder(prefix) abort
    try | exec a:prefix.'older' | catch | endtry
endfunction

function! s:QfNewer(prefix) abort
    try | exec a:prefix.'newer' | catch | endtry
endfunction

function! s:QfSetup() abort
    if exists('w:QfSetup') | return | endif
    let w:QfSetup = 1
    let b:locl = 1
    try | lopen | catch /:E776:/ | let b:locl = 0 | endtry
    unlet w:QfSetup
    let b:prefix = b:locl ? 'l' : 'c'

    call BufSpecialSetup()
    setl nu nobl
    wincmd J

    noremap <buffer> - <Nop>
    noremap <buffer> <F1> <Nop>
    noremap <buffer> <F2> <Nop>
    noremap <buffer> <F4> <Nop>
    noremap <buffer> <F8> <Nop>
    noremap <buffer> <Leader>tf <Nop>
    noremap <buffer> <Leader>tt <Nop>
    noremap <buffer> <Leader>bb <Nop>
    noremap <buffer> <Leader>gg <Nop>
    noremap <buffer> <Leader>G <Nop>

    nmap <buffer> <silent> o <CR>
    nnoremap <buffer> <silent> q :close<CR>
    exec 'nnoremap <buffer> <silent> go :exec "normal! \<lt>cr>" \|
        \ match IncSearch /\k*\%#\k*/ \| '.b:prefix.'open<CR>'
    nnoremap <buffer> <silent> << :call QfOlder(b:prefix)<CR>
    nnoremap <buffer> <silent> >> :call QfNewer(b:prefix)<CR>
    nnoremap <buffer> <silent> <Leader>< :call QfOldest(b:prefix)<CR>
    nnoremap <buffer> <silent> <Leader>> :call QfNewest(b:prefix)<CR>
endfunction

" }}}

" {{{ Add single plugin using 'pathogen'

function! s:Plugin(bang, name) abort
    let path = fnamemodify((empty(a:bang) ? '~/.vim/bundle/' : '').a:name, ':p')
    call pathogen#surround(path)
endfunction

command! -bang -nargs=1 Plugin call s:Plugin(<q-bang>, <args>)

" }}}

" {{{ Toggles diff mode of current buffer

function! s:DiffToggle() abort
   if &diff
        diffoff
    else
        diffthis
    endif
endfunction

command! DiffToggle call s:DiffToggle()
nnoremap <silent> <Leader>dd :DiffToggle<CR>

" }}}

" {{{ Starts diff of current buffer with another file

function! s:Diff2(file) abort
    if !filereadable(a:file)
        call EchoError("Diff2: can't read ".a:file)
        return
    endif
    let filetype = &ft
    diffthis
    exec 'vnew | r '.fnameescape(a:file).' | normal! 1Gdd'
    diffthis
    exec 'setl bt=nofile bh=wipe nobl noswf ft='.filetype
    exec 'silent file Diff2_'.fnameescape(a:file)
    wincmd p
endfunction

command! -nargs=1 -complete=file Diff2 call s:Diff2(<f-args>)
nnoremap <Leader>df :Diff2 <C-R>=expand('%')<CR>

" }}}

" {{{ Toggles translation of ASCII meta escape prefix encoding to 8 bit meta encoding

function! s:MetaLess(cmd) abort
    call TryCatch(a:cmd)
endfunction

if !has('nvim')

function! s:MetaSetup(enable) abort
    " Meta + [0-z]
    " don't include O and P because of conflicts in xterm
    let chars = '0123456789ABCDEFGHIJKLMNQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    let i = 0
    let n = len(chars)
    while i < n
        let c = chars[i]
        if a:enable
            exec 'set <M-'.c.">=\e".c
        else
            exec 'set <M-'.c.'>='
        endif
        let i += 1
    endwhile
    " Meta + C-H, C-L
    if a:enable
        exec "set <M-C-H>=\e\x08"
        exec "set <M-C-L>=\e\x0c"
    else
        set <M-C-H>=
        set <M-C-L>=
    endif
    let g:meta_enabled = a:enable
    if !has('vim_starting')
        redraw
        echohl WarningMsg | echo 'Meta '.(g:meta_enabled ? 'ON' : 'OFF') | echohl None
    endif
endfunction

function! s:MetaLess(cmd) abort
    if g:meta_enabled
        silent call s:MetaSetup(0)
        call TryCatch(a:cmd)
        silent call s:MetaSetup(1)
    else
        call TryCatch(a:cmd)
    endif
endfunction

command! MetaToggle call s:MetaSetup(!meta_enabled)
nnoremap <silent> <Leader>mm :MetaToggle<CR>
silent call s:MetaSetup(1)

endif

" }}}

" {{{ Preserve cursor / window position, last search pattern, and the others

function! s:Preserve(cmd) abort
    " save
    let last_search = @/
    let cursor_pos = getcurpos()
    normal! H
    let window_pos = getpos('.')
    call setpos('.', cursor_pos)
    try
        call TryCatch('keepalt keepjumps keepmarks keeppatterns '.a:cmd)
    finally
        " restore
        call setpos('.', window_pos)
        normal! zt
        call setpos('.', cursor_pos)
        let @/ = last_search
    endtry
endfunction

command! -nargs=1 Preserve call s:Preserve(<q-args>)
nnoremap <silent> <Leader>pp :Preserve %s/\\s\\+$//e<CR>
vnoremap <silent> <Leader>pp :<C-U>Preserve '<,'>s/\\s\\+$//e<CR>
nnoremap <silent> <Leader>== :Preserve silent normal! gg=G<CR>
nnoremap <silent> <Leader>gq :Preserve silent normal! gggqG<CR>

" }}}

" {{{ Closes current or last tab

function! s:QuitTab(bang) abort
    try
        exec 'tabclose'.a:bang
    catch /:E784:/
        exec 'qall'.a:bang
    endtry
endfunction

command! -bang QuitTab call TryCatch('silent call s:QuitTab(<q-bang>)')
nnoremap <silent> QQ :QuitTab<CR>
nnoremap <silent> QA :QuitTab!<CR>

" }}}

" {{{ Walks through list of colorschemes (q/C-C=quit, k=prev, default=next)

function! s:Themes() abort
    let themes = ['luciusblack', 'hybrid', 'bclear']
    let l = len(themes)
    if !exists('s:themes_last_index')
        let s:themes_last_index = 0
    endif
    let i = s:themes_last_index
    while 1
        let theme = themes[i]
        exec 'colorscheme '.theme
        redraw | echo theme
        let c = getchar()
        if c == 3 || c == 113
            break
        elseif c == 107
            let i = i > 0 ? i-1 : l-1
        else
            let i = i < l-1 ? i+1 : 0
        endif
    endwhile
    let s:themes_last_index = i
    redraw | echo
endfunction

command! Themes call s:Themes()
nnoremap <silent> <Leader>th :Themes<CR>

" }}}

" {{{ Write with elevated privileges

function! s:Write(...) abort
    let filename = get(a:, '1', expand('%'))
    exec 'silent write !sudo tee >/dev/null '.shellescape(filename)
    edit!
endfunction

command! -nargs=? W call s:Write(<f-args>)

" }}}

" {{{ Zoom / Restore window

function! s:ZoomToggle() abort
    if exists('t:zoomed') && t:zoomed
        exec t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vertical resize
        let t:zoomed = 1
    endif
endfunction

command! ZoomToggle call s:ZoomToggle()
nnoremap <silent> <M-z> :ZoomToggle<CR>
nnoremap <silent> <M-m> :ZoomToggle<CR>

" }}}

" {{{ MoveToTab <http://vim.wikia.com/wiki/Move_current_window_between_tabs>

function! s:MoveToPrevTab() abort
    if tabpagenr('$') == 1 && winnr('$') == 1
        return
    endif
    let tab_nr = tabpagenr('$')
    let cur_buf = bufnr('%')
    if tabpagenr() != 1
        close!
        if tab_nr == tabpagenr('$')
            tabprev
        endif
        vertical topleft split
    else
        close!
        exe '0tabnew'
    endif
    exe 'b'.cur_buf
endfunc

function! s:MoveToNextTab() abort
    if tabpagenr('$') == 1 && winnr('$') == 1
        return
    endif
    let tab_nr = tabpagenr('$')
    let cur_buf = bufnr('%')
    if tabpagenr() < tab_nr
        close!
        if tab_nr == tabpagenr('$')
            tabnext
        endif
        vertical topleft split
    else
        close!
        tabnew
    endif
    exe 'b'.cur_buf
endfunc

command! MoveToPrevTab call s:MoveToPrevTab()
command! MoveToNextTab call s:MoveToNextTab()
nnoremap <silent> <M-H> :MoveToPrevTab<CR>
nnoremap <silent> <M-L> :MoveToNextTab<CR>

" }}}

" {{{ Prev/NextClosedFold <https://stackoverflow.com/questions/9403098/is-it-possible-to-jump-to-closed-folds-in-vim>

function! s:MoveToClosedFold(next) abort
    let cmd = 'normal! z'.(a:next ? 'j' : 'k')
    let view = winsaveview()
    let [l0, l, open] = [0, view.lnum, 1]
    while l != l0 && open
        exec cmd
        let [l0, l] = [l, line('.')]
        let open = foldclosed(l) < 0
    endwhile
    if open
        call winrestview(view)
    endif
endfunction

command! PrevClosedFold call s:MoveToClosedFold(0)
command! NextClosedFold call s:MoveToClosedFold(1)
nnoremap <silent> <Leader>zk :PrevClosedFold<CR>
nnoremap <silent> <Leader>zj :NextClosedFold<CR>

" }}}

" ----------------------------------------

filetype plugin indent on
if !exists('g:syntax_on')
    syntax enable
endif

runtime ftplugin/man.vim

" just get rid of these
let loaded_getscript = 1
let loaded_getscriptPlugin = 1
let loaded_logipat = 1
let loaded_netrw = 1
let loaded_netrwPlugin = 1
let loaded_rrhelper = 1
let loaded_vimball = 1
let loaded_vimballPlugin = 1

let netrw_alto = 1
let netrw_altv = 1
let netrw_banner = 0
let netrw_bufsettings = 'nonu nornu nowrap nolist nobl cc=0 fdc=0 noma nomod ro'
let netrw_fastbrowse = 1
let netrw_list_cmd = 'ssh USEPORT HOSTNAME ls -Fa -I .'
let netrw_liststyle = 0
let netrw_preview = 1
let netrw_silent = 1
let netrw_special_syntax = 1

Plugin 'ansiesc'
Plugin 'colorschemes'
Plugin 'enhanced-diff'

if has('gui_running')
    colorscheme bclear
endif

augroup vimrc_base
    autocmd!

    autocmd BufEnter,BufWinEnter * match none | set titlestring=
    autocmd BufWritePre * let &backupext = '_'.substitute(expand('%:p:h'), '/', '%', 'g')
    autocmd CmdwinEnter * call BufSpecialSetup()

    if !has('nvim')
        autocmd TermChanged * silent call s:MetaSetup(meta_enabled)
    endif

    if has('nvim')
        autocmd TermOpen * call BufSpecialSetup()
    endif

    " tabpagecd <https://github.com/kana/vim-tabpagecd>
    autocmd TabEnter *
        \  if exists('t:cwd')
        \|     cd `=t:cwd`
        \| endif
    autocmd TabLeave *
        \ let t:cwd = getcwd()

    " Quickfix List / Location List
    autocmd BufEnter,BufWinEnter *
        \  if &ft == 'qf' && exists('w:quickfix_title')
        \|     let &titlestring = '%t '.w:quickfix_title
        \| endif
    autocmd FileType qf call QfSetup()
    autocmd QuickFixCmdPost [^l]* cwindow

    " netrw
    autocmd FileType netrw
        \  call BufSpecialSetup()
        \| nmap <buffer> <silent> o <CR>
        \| keepjumps normal! gg

    autocmd BufWritePost ~/.Xresources !xrdb -load ~/.Xresources

    autocmd FileType mail setl tw=72
    autocmd FileType make setl ts=4 sts=0 sw=4 noexpandtab
    autocmd FileType man call BufSpecialSetup() | setl noma ts=8
    autocmd FileType tar call BufSpecialSetup()
    autocmd FileType zip call BufSpecialSetup()
    autocmd FileType {c,cpp}{,.*} let &l:path = '/usr/include'

augroup END
