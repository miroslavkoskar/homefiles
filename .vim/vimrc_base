" vim: ft=vim fdm=marker

if !exists('$VIMDIR')
    let $VIMDIR = '~/.vim'
endif

if !exists('$VIMRC')
    let $VIMRC = expand('<sfile>:p')
endif

" ========== important
set nocompatible
set pastetoggle=<F6>
set timeout timeoutlen=1000 ttimeoutlen=10
let mapleader = ','
let maplocalleader = ';'

" ========== moving around, searching and patterns
set whichwrap=b,s,<,>,[,]
" .       - current file directory
" (empty) - current working directory
" **      - recursive from current working directory
set path=.,,**,
set incsearch
set ignorecase
set smartcase

" ========== tags
set tags=./tags,tags

if exists("$BASEDIR")
    exec 'set tags^='.$BASEDIR.'/tags'
    nnoremap <silent> <F12> :!$BASEDIR/maketags<CR>
endif

" ========== displaying text
set scrolloff=5
set nowrap
set sidescroll=15
set sidescrolloff=15
set list
set listchars=eol:Â¬,tab:>-,trail:-,extends:>,precedes:<

nnoremap <Leader>L :set <C-R>=&list ? 'nolist' : 'list'<CR><CR>
nnoremap <Leader>W :set <C-R>=&wrap ? 'nowrap' : 'wrap'<CR><CR>

" ========== syntax, highlighting and spelling
set background=dark
set hlsearch
set colorcolumn=+1,84
set spelllang=en_us

let g:option_colorcolumn = &cc

nnoremap <silent> <Space> :nohls<Bar>echo<CR>
nnoremap <silent> # :let @/ = "<C-R>=escape(escape(expand('<cWORD>'), '/\.*$^~["'), '''/\.*$^~["')<CR>"<Bar>set hls<CR>
nnoremap <silent> * :let @/ = "<C-R>=escape(escape(expand('<cword>'), '/\.*$^~["'), '''/\.*$^~["')<CR>"<Bar>set hls<CR>
nnoremap <Leader>sp :set <C-R>=&spell ? 'nospell' : 'spell'<CR><CR>
nnoremap col :set <C-R>=!empty(&cc) ? 'cc=' : 'cc='.g:option_colorcolumn<CR><CR>
nnoremap cuc :set <C-R>=&cuc ? 'nocuc' : 'cuc'<CR><CR>
nnoremap cul :set <C-R>=&cul ? 'nocul' : 'cul'<CR><CR>

" ========== multiple windows
set laststatus=2
set statusline=
set statusline+=%n
set statusline+=\ %<%f
set statusline+=%(\ [%M%W%R]%)
set statusline+=\ [%{&fo}]
set statusline+=%(\ %y%)
set statusline+=%=
set statusline+=0x%-3B
set statusline+=\ %-14(%l,%c%V%)
set statusline+=\ %P
set splitbelow
set splitright

" spatial navigation
nnoremap <C-J> <C-W>j
nnoremap <C-K> <C-W>k
nnoremap <C-H> <C-W>h
nnoremap <C-L> <C-W>l
nmap <BS> <C-H>

nnoremap <silent> c<C-J> :below sp<CR>
nnoremap <silent> c<C-K> :above sp<CR>
nnoremap <silent> c<C-H> :lefta vsp<CR>
nnoremap <silent> c<C-L> :rightb vsp<CR>
nmap c<BS> c<C-H>

nnoremap d<C-J> <C-W>j<C-W>c
nnoremap d<C-K> <C-W>k<C-W>c
nnoremap d<C-H> <C-W>h<C-W>c
nnoremap d<C-L> <C-W>l<C-W>c
nmap d<BS> d<C-H>

nnoremap <C-_> <C-W>_
nnoremap g<C-J> <C-W>j<C-W>_
nnoremap g<C-K> <C-W>k<C-W>_
nnoremap g<C-H> <C-W>h<C-W>_
nnoremap g<C-L> <C-W>l<C-W>_
nmap g<BS> g<C-H>

" faster resizing
nnoremap <silent> - :resize -5<CR>
nnoremap <silent> + :resize +5<CR>
nnoremap <silent> <C-W>, :vert resize -5<CR>
nnoremap <silent> <C-W>. :vert resize +5<CR>

" ========== terminal
set nottybuiltin
set t_ut=

" ========== using the mouse
set mouse=a

noremap <MiddleMouse> <Nop>
noremap <2-MiddleMouse> <Nop>
noremap <3-MiddleMouse> <Nop>
noremap <4-MiddleMouse> <Nop>

inoremap <MiddleMouse> <Nop>
inoremap <2-MiddleMouse> <Nop>
inoremap <3-MiddleMouse> <Nop>
inoremap <4-MiddleMouse> <Nop>

" ========== GUI
set guicursor+=a:blinkon0
set guifont=Monaco\ 12
set guioptions+=c
set guioptions+=e
set guioptions-=m
set guioptions-=r
set guioptions-=L
set guioptions-=T

" ========== messages and info
set shortmess=aoOtTWI
set showcmd
set showmode
set ruler
set novisualbell

" ========== editing text
set textwidth=78
set backspace=indent,eol,start
set formatoptions=croqln21j
set completeopt=longest,menuone
set tildeop
set showmatch

" ========== tabs and indenting
set tabstop=4
set shiftwidth=4
set smarttab
set softtabstop=0
set expandtab
set autoindent
set smartindent
set copyindent
set preserveindent

" ========== folding
set foldcolumn=0

nnoremap <Leader>ff :set fdm=manual<CR>
nnoremap <Leader>fi :set fdm=indent<CR>
nnoremap <Leader>fs :set fdm=syntax<CR>
nnoremap <Leader>fm :set fdm=marker<CR>

" ========== reading and writing files
set modeline
set backup
exec 'set backupdir='.$VIMDIR.'/.backup'
set autoread

" ========== the swap file
exec 'set directory=~/.vim/.swap//,'.$TMPDIR.'//'
set swapfile

" ========== command line editing
set history=500
set wildmode=list:longest,full
set wildignore=
set wildmenu
set undofile
exec 'set undodir='.$VIMDIR.'/.undo'

" ========== executing external commands
set shell=~/bin/bashx
set shellredir=>%s\ 2>&1

" ========== running make and jumping to errors
set shellpipe=2>&1\|\ tee
set grepprg=grep\ -n\ --exclude-dir='.svn'\ --exclude-dir='.git'\ --exclude='*.swp'\ --exclude='*~'\ $*\ /dev/null

nnoremap <silent> <F9> :make!<CR>

nnoremap <silent> <Leader>cl :copen<CR>
nnoremap <silent> <Leader>ll :lopen<CR>

nnoremap <silent> <Leader>j :cnext<CR>
nnoremap <silent> <Leader>k :cprevious<CR>

nnoremap <silent> <Leader>J :lnext<CR>
nnoremap <silent> <Leader>K :lprevious<CR>

" ========== multi-byte characters
set encoding=utf-8

" ========== clipboard

function! s:Pipe2(cmd, bang) range abort
    if empty(a:bang)
        exec a:firstline.','.a:lastline.' yank '.v:register
    endif
    call system(a:cmd, getreg())
endfunction
command! -register -range -bang -nargs=1 Pipe2 Preserve <line1>,<line2> call s:Pipe2(<q-args>, <q-bang>)
command! -register -range -bang Pipe2Primary Preserve <line1>,<line2> call s:Pipe2('xclip -i', <q-bang>)
command! -register -range -bang Pipe2Clipboard Preserve <line1>,<line2> call s:Pipe2('xclip -i -selection clipboard', <q-bang>)

nnoremap <silent> <Leader>xxP :Pipe2Primary!<CR>
nnoremap <silent> <Leader>xxp yy:Pipe2Primary!<CR>
vnoremap <silent> <Leader>xxp y:Pipe2Primary!<CR>

nnoremap <silent> <Leader>xxC :Pipe2Clipboard!<CR>
nnoremap <silent> <Leader>xxc yy:Pipe2Clipboard!<CR>
vnoremap <silent> <Leader>xxc y:Pipe2Clipboard!<CR>

" ========== various
set gdefault
set virtualedit=block
exec "set viminfo='100,<50,s10,h,n".$VIMDIR."/.viminfo"

nnoremap cov :set <C-R>=&virtualedit =~# 'all' ? 'virtualedit=block' : 'virtualedit=all'<CR><CR>

" ========== other
let g:load_doxygen_syntax = 1

syntax on
filetype plugin indent on

if &t_Co == 256
    colorscheme luciusblack
else
    colorscheme desert
endif

" make Man available
runtime ftplugin/man.vim

" let Y yank not entire line, but from cursor to the end (consistent with D, C)
nnoremap Y y$
" no Ex mode
nnoremap Q <nop>
" no Man lookup
nnoremap K <nop>
" no useless help messages
nnoremap <C-c> <silent> <C-c>

" operate on display lines not file lines
noremap j gj
noremap k gk

map <M-j> 5j
map <M-k> 5k

noremap <M-C-H> 15h
noremap <M-C-L> 15l

noremap <C-E> 5<C-E>
noremap <C-Y> 5<C-Y>

noremap zh 15zh
noremap zl 15zl

nnoremap <M-n> :tabnew<CR>
nnoremap <M-l> gt
nnoremap <M-h> gT
nnoremap <M-1> 1gt
nnoremap <M-2> 2gt
nnoremap <M-3> 3gt
nnoremap <M-4> 4gt
nnoremap <M-5> 5gt
nnoremap <M-6> 6gt
nnoremap <M-7> 7gt
nnoremap <M-8> 8gt
nnoremap <M-9> 9gt
nnoremap <silent> <M-0> :tablast<CR>

cnoremap %% <C-R>=expand('%:h').'/'<CR>
nmap <Leader>ew :e %%
nmap <Leader>es :sp %%
nmap <Leader>ev :vsp %%
nmap <Leader>et :tabe %%

inoremap <C-F>f <C-R>=expand('%:t')<CR>
inoremap <C-F>n <C-R>=expand('%:t:r')<CR>
inoremap <C-F>p <C-R>=expand('%:p')<CR>
inoremap <C-F>d <C-R>=expand('%:r')<CR>

nnoremap <Leader>a ggVG
vnoremap <Leader>a <Esc>ggVG
nnoremap <Leader>h :tab help<Space>
nnoremap <Leader>H :tab lhelpgrep<Space>

nnoremap <silent> <C-X> :q<CR>
nnoremap <silent> <C-Q> :bd<CR>
nnoremap <silent> <Leader>ee :e<CR>
nnoremap <silent> <Leader>EE :e!<CR>
nnoremap <Leader>rr :setl noreadonly modifiable<CR>

nnoremap <expr> gp '`['.getregtype()[0].'`]'

" sorting
vnoremap <silent> <Leader>ss :sort<CR>
vnoremap <silent> <Leader>su :sort u<CR>
vnoremap <silent> <Leader>sd :sort!<CR>
vnoremap <silent> <Leader>sb :!sort-blocks<CR>

" working on diffs
nnoremap <silent> <Leader>du :diffup<CR>
nnoremap <silent> <Leader>d; :,diffget<CR>
nnoremap <silent> <Leader>d: :,diffput<CR>

" XML prettify
vnoremap <silent> <Leader>px :!tidy -config ~/.tidyrc -xml<CR>
nnoremap <silent> <Leader>px :%!tidy -config ~/.tidyrc -xml<CR>

" reformat paragraph
vnoremap <silent> <Leader>pr :!reformat<CR>
nnoremap <silent> <Leader>pr :%!reformat<CR>

" strip_lines / squash
vnoremap <silent> <Leader>ps :!strip_lines<CR>
nnoremap <silent> <Leader>ps :%!strip_lines<CR>
vnoremap <silent> <Leader>pS :!squash<CR>
nnoremap <silent> <Leader>pS :%!squash<CR>

" fast editing / reloading of the 'vimrc'
exec 'nnoremap <silent> <Leader>rc :vs '.$VIMRC.'<CR>'
exec 'nnoremap <Leader>so :source '.$VIMRC.'<CR>'

nnoremap <silent> <Leader>ft :exec 'set ft='.&ft<CR>

" ----------------------------------------

" ========== netrw
let netrw_alto = 1
let netrw_altv = 1
let netrw_banner = 1
let netrw_bufsettings = 'noma nomod nonu nowrap ro nolist cc=0 fdc=0'
let netrw_fastbrowse = 2
let netrw_list_cmd = 'sshm USEPORT HOSTNAME ls -Fa -I .'
let netrw_liststyle = 0
let netrw_preview = 1
let netrw_retmap = 1
let netrw_scp_cmd = 'scpm -q'
let netrw_sftp_cmd = 'sftpm'
let netrw_silent = 1
let netrw_special_syntax = 1
let netrw_winsize = 30

" ----------------------------------------

" Echos given error message.
function! EchoError(errmsg) abort
    if empty(a:errmsg)
        redraw
        echohl ErrorMsg | echomsg a:errmsg | echohl None
    endif
endfunction

" Echos most recently caught exception (removing Vim 'class').
function! EchoException() abort
    redraw
    echohl ErrorMsg
    echo substitute(v:exception, '^Vim(.*):', '', 'g')
    echohl None
endfunction

" Echos last given error message.
function! EchoLastError() abort
    call EchoError(v:errmsg)
endfunction

" Performs exec of passed command in try/catch block catching matching errors.
function! TryCatch(cmd, ...) abort
    let pattern = '.*'
    if a:0
        let pattern = a:1
    endif
    exec 'try | '.a:cmd.' | catch /'.pattern.'/ | call EchoException() | endtry'
endfunction

function! BufferSettings_Man()
    call BufferSettings_Special()
    setl noma ts=8
endfunction

function! BufferSettings_Special()
    setl nonu nowrap nolist cc=0 fdc=0
endfunction

" ----------------------------------------

" {{{ Toggles diff mode of current buffer.

function! s:DiffToggle() abort
   if &diff
        diffoff
    else
        diffthis
    endif
endfunction
command! DiffToggle call s:DiffToggle()
nnoremap <silent> <Leader>dd :DiffToggle<CR>

" }}}

" {{{ Starts diff of current buffer with another file.

function! s:Diff2(file) abort
    if !filereadable(a:file)
        call EchoError("Diff2: can't read ".a:file)
        return
    endif
    let filetype = &ft
    diffthis
    exec 'vnew | r '.a:file.' | normal! 1Gdd'
    diffthis
    exec 'setl bt=nofile bh=wipe nobl noswf ft='.filetype
    exec 'silent file DIFF_'.a:file
endfunction
command! -nargs=1 -complete=file Diff2 call s:Diff2(<f-args>)
nnoremap <Leader>df :Diff2 <C-R>=expand('%')<CR>

" }}}

" {{{ Toggles translation of ASCII meta escape prefix encoding to 8 bit meta encoding.

function! MetaSetup(enable) abort
    " Meta + [0-z]
    " don't include O and P because of conflicts in xterm
    let chars = '0123456789ABCDEFGHIJKLMNQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    let i = 0
    let n = len(chars)
    while i < n
        let c = chars[i]
        if a:enable
            exec 'set <M-'.c.">=\e".c
        else
            exec 'set <M-'.c.'>='
        endif
        let i += 1
    endwhile
    " Meta + C-H, C-L
    if a:enable
        exec "set <M-C-H>=\e\x08"
        exec "set <M-C-L>=\e\x0c"
    else
        set <M-C-H>=
        set <M-C-L>=
    endif
    let g:meta_enabled = a:enable
    if !has('vim_starting')
        redraw
        echohl WarningMsg | echo 'Meta '.(g:meta_enabled ? 'ON' : 'OFF') | echohl None
    endif
endfunction
command! MetaToggle call MetaSetup(!meta_enabled)
nnoremap <silent> <Leader>mm :MetaToggle<CR>
silent call MetaSetup(1)

" }}}

" {{{ Restore cursor position, window position,
" and last search pattern after running a command.

function! Preserve(cmd) abort
    " save
    let last_search = @/
    let cursor_pos = getcurpos()
    normal H
    let window_pos = getpos('.')
    call setpos('.', cursor_pos)
    try
        exec a:cmd
    finally
        " restore
        call setpos('.', window_pos)
        normal zt
        call setpos('.', cursor_pos)
        let @/ = last_search
    endtry
endfunction
command! -nargs=1 Preserve call Preserve(<q-args>)
nnoremap <silent> <Leader>pp :Preserve %s/\s\+$//e<CR>
vnoremap <silent> <Leader>pp :Preserve '<,'>s/\\s\\+$//e<CR>
nnoremap <silent> <Leader>== :Preserve normal gg=G<CR>

" }}}

" {{{ Closes current or last tab.

function! s:QuitTab(bang) abort
    try
        exec 'tabclose'.a:bang
    catch /:E784:/
        exec 'qall'.a:bang
    endtry
endfunction
command! -bang QuitTab call TryCatch('silent call s:QuitTab(<q-bang>)')
nnoremap <silent> QQ :QuitTab<CR>
nnoremap <silent> QA :QuitTab!<CR>

" }}}

" {{{ Walks through list of colorschemes (q/C-C=quit, k=prev, default=next).

function! s:Themes() abort
    let themes = ['luciusblack', 'hybrid', 'bclear']
    let l = len(themes)
    if !exists('s:themes_last_index')
        let s:themes_last_index = 0
    endif
    let i = s:themes_last_index
    while 1
        let theme = themes[i]
        exec 'colorscheme '.theme
        redraw | echo theme
        let c = getchar()
        if c == 3 || c == 113
            break
        elseif c == 107
            let i = i > 0 ? i-1 : l-1
        else
            let i = i < l-1 ? i+1 : 0
        endif
    endwhile
    let s:themes_last_index = i
    redraw | echo
endfunction
command! Themes call s:Themes()
nnoremap <silent> <Leader>th :Themes<CR>

" }}}

" {{{ Write with elevated privileges.

function! s:Write(...) abort
    let file = '%'
    if a:0
        let file = a:1
    endif
    exec 'silent write !sudo tee >/dev/null '.file
    edit!
endfunction
command! -nargs=? W call s:Write(<f-args>)

" }}}

" {{{ Zoom / Restore window.

function! s:ZoomToggle() abort
    if exists('t:zoomed') && t:zoomed
        exec t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vertical resize
        let t:zoomed = 1
    endif
endfunction
command! ZoomToggle call s:ZoomToggle()
nnoremap <silent> <M-z> :ZoomToggle<CR>
nnoremap <silent> <M-m> :ZoomToggle<CR>

" }}}

" {{{ http://vim.wikia.com/wiki/Move_current_window_between_tabs

function! s:MoveToPrevTab() abort
    if tabpagenr('$') == 1 && winnr('$') == 1
        return
    endif
    let tab_nr = tabpagenr('$')
    let cur_buf = bufnr('%')
    if tabpagenr() != 1
        close!
        if tab_nr == tabpagenr('$')
            tabprev
        endif
        vert topleft split
    else
        close!
        exe '0tabnew'
    endif
    exe 'b'.cur_buf
endfunc
command! MoveToPrevTab call s:MoveToPrevTab()
nnoremap <silent> <M-H> :MoveToPrevTab<CR>

function! s:MoveToNextTab() abort
    if tabpagenr('$') == 1 && winnr('$') == 1
        return
    endif
    let tab_nr = tabpagenr('$')
    let cur_buf = bufnr('%')
    if tabpagenr() < tab_nr
        close!
        if tab_nr == tabpagenr('$')
            tabnext
        endif
        vert topleft split
    else
        close!
        tabnew
    endif
    exe 'b'.cur_buf
endfunc
command! MoveToNextTab call s:MoveToNextTab()
nnoremap <silent> <M-L> :MoveToNextTab<CR>

" }}}

" ----------------------------------------

if has('autocmd')
augroup VIMRC_BASE
    autocmd!

    autocmd BufWritePre * let &backupext = '_'.substitute(expand('%:p:h'), '/', '%', 'g')
    autocmd CmdwinEnter * call BufferSettings_Special()
    autocmd TermChanged * silent call MetaSetup(meta_enabled)

    autocmd BufWinEnter NetrwMessage nnoremap <silent> <buffer> q :q<CR>

    " Quickfix List / Location List
    autocmd BufEnter * match none
    autocmd BufWinEnter quickfix
        \  call BufferSettings_Special()
        \| map <buffer> <silent> o <CR>
        \| map <buffer> <silent> go <CR>:match IncSearch /\k*\%#\k*/<CR><C-W>p
        \| map <buffer> <silent> < :try \| call TryCatch('lolder', '^\(.*:E776:.*\)\@!') \| catch \| call TryCatch('colder') \| endtry<CR>
        \| map <buffer> <silent> > :try \| call TryCatch('lnewer', '^\(.*:E776:.*\)\@!') \| catch \| call TryCatch('cnewer') \| endtry<CR>
        \| map <buffer> <silent> q <C-W>q<CR>

    " ----------------------------------------

    " C/C++
    autocmd FileType {c,cpp}{,.*} let &l:path = '/usr/include'

    " other
    autocmd FileType mail setl tw=72
    autocmd FileType make setl ts=4 sts=0 sw=4 noexpandtab
    autocmd FileType man call BufferSettings_Man()
    autocmd FileType netrw call BufferSettings_Special()
    autocmd FileType tar call BufferSettings_Special()
    autocmd FileType zip call BufferSettings_Special()

augroup END
endif
